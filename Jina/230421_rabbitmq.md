# 동기 vs 비동기

**작업 완료 확인 주체**

**동기**는 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것이다.

**비동기**는 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다. 함수 A는 함수 B를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않는다.

# 블로킹 vs 넌블로킹

**제어권 처리 (제어권 : 자신(함수)의 코드를 실행할 권리)**

**블로킹**은 A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B 함수에 넘겨준다.

**논블로킹**은 A함수가 B함수를 호출해도 제어권은 그대로 자신이 가지고 있는다.

# 비동기 처리

- 일반적인 코드는 순차적으로 실행

- 특정 명령어들의 모음을 별도의 작업 흐름으로 생성하여 명령

- 제어권을 바로 이어받을 수 있게 만든 방식이 비동기 처리 방식

- 프레임워크에서 제공하는 방법 -> async

-> REST API 비동기로 처리했을 때 속도는 빨라지지만 WAS 재실행, 서버 이상 등 이슈가 발생하면 요청 데이터 사라짐

-> 메세지 큐로 대체

# 메세지 큐

- 메세지의 버퍼 역할을 하며 비동기적으로 전송

- 서비스(서버)간 느슨한 결합이 가능 (서버 이슈 발생해도 메세지큐에 남아있음)

- 메세지의 무손실 보장

- 발행, 소비

- 이기종간 메세징에도 적합

# RabbitMQ

- 손쉽게 작업을 처리하는 별도 서비스의 scale-out이 가능

- 다양한 클라이언트 라이브러리 제공

- 메시지 디스크 저장 설정 기능

- 메세지 무손실(영속성) 보장

- 고가용성을 위한 클러스터 설정 가능

- 접근성 좋은 Web UI 제공
