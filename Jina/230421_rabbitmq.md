# 동기 vs 비동기

**작업 완료 확인 주체**

**동기**는 함수 A가 함수 B를 호출한 뒤, 함수 B의 리턴값을 계속 확인하면서 신경쓰는 것이다.

**비동기**는 함수 A가 함수 B를 호출할 때 콜백 함수를 함께 전달해서, 함수 B의 작업이 완료되면 함께 보낸 콜백 함수를 실행한다. 함수 A는 함수 B를 호출한 후로 함수 B의 작업 완료 여부에는 신경쓰지 않는다.

# 블로킹 vs 넌블로킹

**제어권 처리 (제어권 : 자신(함수)의 코드를 실행할 권리)**

**블로킹**은 A 함수가 B 함수를 호출하면, 제어권을 A가 호출한 B 함수에 넘겨준다.

**논블로킹**은 A함수가 B함수를 호출해도 제어권은 그대로 자신이 가지고 있는다.

# 비동기 처리

- 일반적인 코드는 순차적으로 실행

- 특정 명령어들의 모음을 별도의 작업 흐름으로 생성하여 명령

- 제어권을 바로 이어받을 수 있게 만든 방식이 비동기 처리 방식

- 프레임워크에서 제공하는 방법 -> async

-> REST API 비동기로 처리했을 때 속도는 빨라지지만 WAS 재실행, 서버 이상 등 이슈가 발생하면 요청 데이터 사라짐

-> 메세지 큐로 대체

# 메세지 큐

- 메세지의 버퍼 역할을 하며 비동기적으로 전송

- 서비스(서버)간 느슨한 결합이 가능 (서버 이슈 발생해도 메세지큐에 남아있음)

- 메세지의 무손실 보장

- 발행, 소비

- 이기종간 메세징에도 적합

# RabbitMQ

- 손쉽게 작업을 처리하는 별도 서비스의 scale-out이 가능

- 다양한 클라이언트 라이브러리 제공

- 메시지 디스크 저장 설정 기능

- 메세지 무손실(영속성) 보장

- 고가용성을 위한 클러스터 설정 가능

- 접근성 좋은 Web UI 제공



# 이벤트큐 vs 메세지큐

|       | 이벤트 큐                     | 메시지 큐                       |
| ----- | ------------------------- | --------------------------- |
| 목적    | 이벤트 처리                    | 메시지 전송 및 처리                 |
| 처리 방식 | 이벤트 발생 순서대로 처리            | 메시지를 받는 대상이 처리하기 적합한 시점에 처리 |
| 처리 방법 | 비동기적으로 처리                 | 동기적으로 처리                    |
| 사용 예시 | UI 프로그래밍에서 이벤트 처리에 사용됨    | 시스템 간 통신, 이벤트 처리 등에 사용됨     |
| 순서 중요 | 중요함                       | 순서가 중요하지 않음                 |
| 특징    | UI 스레드를 차단하지 않고 비동기 처리 가능 | 메시지 전송 후 대기하여 처리            |
